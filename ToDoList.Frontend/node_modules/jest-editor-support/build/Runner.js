"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
require("core-js/modules/es.reflect.construct.js");
require("core-js/modules/es.object.create.js");
require("core-js/modules/es.object.define-property.js");
require("core-js/modules/es.symbol.to-primitive.js");
require("core-js/modules/es.date.to-primitive.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.number.constructor.js");
require("core-js/modules/es.array.is-array.js");
require("core-js/modules/es.symbol.iterator.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.weak-map.js");
require("core-js/modules/es.object.get-own-property-descriptor.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
require("core-js/modules/es.array.for-each.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/web.dom-collections.for-each.js");
require("core-js/modules/es.array.map.js");
require("core-js/modules/es.string.starts-with.js");
require("core-js/modules/es.date.to-string.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.array.concat.js");
require("core-js/modules/es.array.find.js");
require("core-js/modules/es.object.set-prototype-of.js");
require("core-js/modules/es.function.bind.js");
require("core-js/modules/es.object.get-prototype-of.js");
var _child_process = require("child_process");
var _fs = require("fs");
var _os = require("os");
var path = _interopRequireWildcard(require("path"));
var _events = _interopRequireDefault(require("events"));
var _types = require("./types");
var _project_workspace = _interopRequireDefault(require("./project_workspace"));
var _Process = require("./Process");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
// This class represents the running process, and
// passes out events when it understands what data is being
// pass sent out of the process
var Runner = /*#__PURE__*/function (_EventEmitter) {
  _inherits(Runner, _EventEmitter);
  var _super = _createSuper(Runner);
  // $FlowIgnore[value-as-type]

  // $FlowIgnore[value-as-type]

  // $FlowIgnore[value-as-type]
  function Runner(workspace, options) {
    var _this;
    _classCallCheck(this, Runner);
    _this = _super.call(this);
    _this._createProcess = options && options.createProcess || _Process.createProcess;
    _this.options = options || {};
    _this.workspace = workspace;
    _this.outputPath = path.join((0, _os.tmpdir)(), "jest_runner_".concat(_this.workspace.outputFileSuffix || '', ".json"));
    _this.prevMessageTypes = [];
    _this._exited = false;
    return _this;
  }
  _createClass(Runner, [{
    key: "_getArgs",
    value: function _getArgs() {
      if (this.options.args && this.options.args.replace) {
        return this.options.args.args;
      }

      // Handle the arg change on v18
      var belowEighteen = this.workspace.localJestMajorVersion < 18;
      var outputArg = belowEighteen ? '--jsonOutputFile' : '--outputFile';
      var args = ['--testLocationInResults', '--json', '--useStderr', outputArg, this.outputPath];
      if (this.watchMode) {
        args.push(this.watchAll ? '--watchAll' : '--watch');
      }
      if (this.options.testNamePattern) {
        args.push('--testNamePattern', this.options.testNamePattern);
      }
      if (this.options.testFileNamePattern) {
        args.push(this.options.testFileNamePattern);
      }
      if (this.workspace.collectCoverage === true) {
        args.push('--coverage');
      }
      if (this.workspace.collectCoverage === false) {
        args.push('--no-coverage');
      }
      if (this.options.noColor === true) {
        args.push('--no-color');
      }
      if (this.options.reporters) {
        this.options.reporters.forEach(function (reporter) {
          args.push('--reporters', reporter);
        });
      }
      if (this.options.args) {
        var _args;
        (_args = args).push.apply(_args, _toConsumableArray(this.options.args.args));
      }
      if (this.workspace.useDashedArgs) {
        args = args.map(function (arg) {
          return arg && arg.startsWith('--') && arg.length > 2 ? arg.replace(/(\B)([A-Z])/gm, '-$2').toLowerCase() : arg;
        });
      }
      return args;
    }
  }, {
    key: "start",
    value: function start() {
      var _this2 = this;
      var watchMode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var watchAll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      if (this.debugprocess) {
        return;
      }
      this.watchMode = watchMode;
      this.watchAll = watchAll;
      var args = this._getArgs();
      var debugprocess = this._createProcess(this.workspace, args);
      this.debugprocess = debugprocess;
      debugprocess.stdout.on('data', function (data) {
        _this2._parseOutput(data, false);
      });
      debugprocess.stderr.on('data', function (data) {
        // jest 23 could send test results message to stderr
        // see https://github.com/facebook/jest/pull/4858
        _this2._parseOutput(data, true);
      });
      debugprocess.on('exit', function (code, signal) {
        _this2._exited = true;

        // this is mainly for backward compatibility, should be deprecated soon
        _this2.emit('debuggerProcessExit');
        _this2.emit('processExit', code, signal);
        _this2.prevMessageTypes.length = 0;
      });
      debugprocess.on('error', function (error) {
        _this2.emit('terminalError', "Process failed: ".concat(error.message));
        _this2.prevMessageTypes.length = 0;
      });
      debugprocess.on('close', function (code, signal) {
        // this is mainly for backward compatibility, should be deprecated soon
        _this2.emit('debuggerProcessExit');
        _this2.emit('processClose', code, signal);
        _this2.prevMessageTypes.length = 0;
      });
    }

    /**
     * parse the stdin/out stream buffer for recognized messages.
     *
     * note: if these messages coming in in separate chucks, we might not be able to
     * resolve it properly. While there haven't been much evidence of such scenario,
     * it's worth to note that it could and we might need to buffer them in that case.
     * see https://github.com/jest-community/jest-editor-support/pull/9#pullrequestreview-231888752
     *
     * @param {Buffer} data
     * @param {boolean} isStdErr
     * @returns {MessageType}
     * @memberof Runner
     */
  }, {
    key: "_parseOutput",
    value: function _parseOutput(data, isStdErr) {
      var _this3 = this;
      var msgType = this.findMessageType(data);
      switch (msgType) {
        case _types.messageTypes.testResults:
          this.emit('executableStdErr', data, {
            type: msgType
          });
          (0, _fs.readFile)(this.outputPath, 'utf8', function (err, _data) {
            if (err) {
              var message = "JSON report not found at ".concat(_this3.outputPath);
              _this3.emit('terminalError', message);
            } else {
              var noTestsFound = _this3.doResultsFollowNoTestsFoundMessage();
              _this3.emit('executableJSON', JSON.parse(_data), {
                noTestsFound: noTestsFound
              });
            }
          });
          this.prevMessageTypes.length = 0;
          break;
        case _types.messageTypes.watchUsage:
        case _types.messageTypes.noTests:
          this.prevMessageTypes.push(msgType);
          this.emit('executableStdErr', data, {
            type: msgType
          });
          break;
        default:
          // no special action needed, just report the output by its source
          if (isStdErr) {
            this.emit('executableStdErr', data, {
              type: msgType
            });
          } else {
            // remove clear screen escape sequence
            this.emit('executableOutput', data.toString().replace('[2J[H', ''));
          }
          this.prevMessageTypes.length = 0;
          break;
      }
      return msgType;
    }
  }, {
    key: "runJestWithUpdateForSnapshots",
    value: function runJestWithUpdateForSnapshots(completion, args) {
      var defaultArgs = ['--updateSnapshot'];
      var updateProcess = this._createProcess(this.workspace, [].concat(defaultArgs, _toConsumableArray(args || [])));
      updateProcess.on('close', function () {
        completion();
      });
    }
  }, {
    key: "closeProcess",
    value: function closeProcess() {
      if (!this.debugprocess || this._exited) {
        // eslint-disable-next-line no-console
        console.log("process has not started or already exited");
        return;
      }
      if (process.platform === 'win32') {
        // Windows doesn't exit the process when it should.
        (0, _child_process.spawn)('taskkill', ['/pid', "".concat(this.debugprocess.pid), '/T', '/F']);
      } else {
        try {
          // kill all process with the same PGID, i.e.
          // as a detached process, it is the same as the PID of the leader process.
          process.kill(-this.debugprocess.pid);
        } catch (e) {
          var _this$debugprocess, _this$debugprocess2;
          // if anything goes wrong, fallback to the old benavior
          // knowing this could leave orphan process...
          // eslint-disable-next-line no-console
          console.warn("failed to kill process group, this could leave some orphan process whose ppid=".concat(((_this$debugprocess = this.debugprocess) === null || _this$debugprocess === void 0 ? void 0 : _this$debugprocess.pid) || 'process-non-exist', ". error="), e);
          (_this$debugprocess2 = this.debugprocess) === null || _this$debugprocess2 === void 0 ? void 0 : _this$debugprocess2.kill();
        }
      }
      this.debugprocess = undefined;
    }

    // eslint-disable-next-line class-methods-use-this
  }, {
    key: "findMessageType",
    value: function findMessageType(buf) {
      var noTestRegex = /No tests found related to files changed since ((last commit)|("[a-z0-9]+"))./;
      var watchUsageRegex = /^\s*Watch Usage\b/;
      var testResultsRegex = /Test results written to/;
      var checks = [{
        regex: testResultsRegex,
        messageType: _types.messageTypes.testResults
      }, {
        regex: noTestRegex,
        messageType: _types.messageTypes.noTests
      }, {
        regex: watchUsageRegex,
        messageType: _types.messageTypes.watchUsage
      }];
      var str = buf.toString('utf8');
      var match = checks.find(function (_ref) {
        var regex = _ref.regex;
        return regex.test(str);
      });
      return match ? match.messageType : _types.messageTypes.unknown;
    }
  }, {
    key: "doResultsFollowNoTestsFoundMessage",
    value: function doResultsFollowNoTestsFoundMessage() {
      if (this.prevMessageTypes.length === 1) {
        return this.prevMessageTypes[0] === _types.messageTypes.noTests;
      }
      if (this.prevMessageTypes.length === 2) {
        return this.prevMessageTypes[0] === _types.messageTypes.noTests && this.prevMessageTypes[1] === _types.messageTypes.watchUsage;
      }
      return false;
    }
  }]);
  return Runner;
}(_events["default"]);
exports["default"] = Runner;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJSdW5uZXIiLCJ3b3Jrc3BhY2UiLCJvcHRpb25zIiwiX2NyZWF0ZVByb2Nlc3MiLCJjcmVhdGVQcm9jZXNzIiwib3V0cHV0UGF0aCIsInBhdGgiLCJqb2luIiwidG1wZGlyIiwib3V0cHV0RmlsZVN1ZmZpeCIsInByZXZNZXNzYWdlVHlwZXMiLCJfZXhpdGVkIiwiYXJncyIsInJlcGxhY2UiLCJiZWxvd0VpZ2h0ZWVuIiwibG9jYWxKZXN0TWFqb3JWZXJzaW9uIiwib3V0cHV0QXJnIiwid2F0Y2hNb2RlIiwicHVzaCIsIndhdGNoQWxsIiwidGVzdE5hbWVQYXR0ZXJuIiwidGVzdEZpbGVOYW1lUGF0dGVybiIsImNvbGxlY3RDb3ZlcmFnZSIsIm5vQ29sb3IiLCJyZXBvcnRlcnMiLCJmb3JFYWNoIiwicmVwb3J0ZXIiLCJ1c2VEYXNoZWRBcmdzIiwibWFwIiwiYXJnIiwic3RhcnRzV2l0aCIsImxlbmd0aCIsInRvTG93ZXJDYXNlIiwiZGVidWdwcm9jZXNzIiwiX2dldEFyZ3MiLCJzdGRvdXQiLCJvbiIsImRhdGEiLCJfcGFyc2VPdXRwdXQiLCJzdGRlcnIiLCJjb2RlIiwic2lnbmFsIiwiZW1pdCIsImVycm9yIiwibWVzc2FnZSIsImlzU3RkRXJyIiwibXNnVHlwZSIsImZpbmRNZXNzYWdlVHlwZSIsIm1lc3NhZ2VUeXBlcyIsInRlc3RSZXN1bHRzIiwidHlwZSIsInJlYWRGaWxlIiwiZXJyIiwiX2RhdGEiLCJub1Rlc3RzRm91bmQiLCJkb1Jlc3VsdHNGb2xsb3dOb1Rlc3RzRm91bmRNZXNzYWdlIiwiSlNPTiIsInBhcnNlIiwid2F0Y2hVc2FnZSIsIm5vVGVzdHMiLCJ0b1N0cmluZyIsImNvbXBsZXRpb24iLCJkZWZhdWx0QXJncyIsInVwZGF0ZVByb2Nlc3MiLCJjb25zb2xlIiwibG9nIiwicHJvY2VzcyIsInBsYXRmb3JtIiwic3Bhd24iLCJwaWQiLCJraWxsIiwiZSIsIndhcm4iLCJ1bmRlZmluZWQiLCJidWYiLCJub1Rlc3RSZWdleCIsIndhdGNoVXNhZ2VSZWdleCIsInRlc3RSZXN1bHRzUmVnZXgiLCJjaGVja3MiLCJyZWdleCIsIm1lc3NhZ2VUeXBlIiwic3RyIiwibWF0Y2giLCJmaW5kIiwidGVzdCIsInVua25vd24iLCJFdmVudEVtaXR0ZXIiXSwic291cmNlcyI6WyIuLi9zcmMvUnVubmVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG5pbXBvcnQge0NoaWxkUHJvY2Vzcywgc3Bhd259IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0IHtyZWFkRmlsZX0gZnJvbSAnZnMnO1xuaW1wb3J0IHt0bXBkaXJ9IGZyb20gJ29zJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQge21lc3NhZ2VUeXBlc30gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgdHlwZSB7T3B0aW9ucywgTWVzc2FnZVR5cGV9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IFByb2plY3RXb3Jrc3BhY2UgZnJvbSAnLi9wcm9qZWN0X3dvcmtzcGFjZSc7XG5pbXBvcnQge2NyZWF0ZVByb2Nlc3N9IGZyb20gJy4vUHJvY2Vzcyc7XG5cbi8vIFRoaXMgY2xhc3MgcmVwcmVzZW50cyB0aGUgcnVubmluZyBwcm9jZXNzLCBhbmRcbi8vIHBhc3NlcyBvdXQgZXZlbnRzIHdoZW4gaXQgdW5kZXJzdGFuZHMgd2hhdCBkYXRhIGlzIGJlaW5nXG4vLyBwYXNzIHNlbnQgb3V0IG9mIHRoZSBwcm9jZXNzXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSdW5uZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBkZWJ1Z3Byb2Nlc3M6ID9DaGlsZFByb2Nlc3M7XG5cbiAgb3V0cHV0UGF0aDogc3RyaW5nO1xuXG4gIC8vICRGbG93SWdub3JlW3ZhbHVlLWFzLXR5cGVdXG4gIHdvcmtzcGFjZTogUHJvamVjdFdvcmtzcGFjZTtcblxuICAvLyAkRmxvd0lnbm9yZVt2YWx1ZS1hcy10eXBlXVxuICBfY3JlYXRlUHJvY2VzczogKHdvcmtzcGFjZTogUHJvamVjdFdvcmtzcGFjZSwgYXJnczogQXJyYXk8c3RyaW5nPikgPT4gQ2hpbGRQcm9jZXNzO1xuXG4gIHdhdGNoTW9kZTogYm9vbGVhbjtcblxuICB3YXRjaEFsbDogYm9vbGVhbjtcblxuICBvcHRpb25zOiBPcHRpb25zO1xuXG4gIHByZXZNZXNzYWdlVHlwZXM6IE1lc3NhZ2VUeXBlW107XG5cbiAgX2V4aXRlZDogYm9vbGVhbjtcblxuICAvLyAkRmxvd0lnbm9yZVt2YWx1ZS1hcy10eXBlXVxuICBjb25zdHJ1Y3Rvcih3b3Jrc3BhY2U6IFByb2plY3RXb3Jrc3BhY2UsIG9wdGlvbnM/OiBPcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX2NyZWF0ZVByb2Nlc3MgPSAob3B0aW9ucyAmJiBvcHRpb25zLmNyZWF0ZVByb2Nlc3MpIHx8IGNyZWF0ZVByb2Nlc3M7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLndvcmtzcGFjZSA9IHdvcmtzcGFjZTtcbiAgICB0aGlzLm91dHB1dFBhdGggPSBwYXRoLmpvaW4odG1wZGlyKCksIGBqZXN0X3J1bm5lcl8ke3RoaXMud29ya3NwYWNlLm91dHB1dEZpbGVTdWZmaXggfHwgJyd9Lmpzb25gKTtcbiAgICB0aGlzLnByZXZNZXNzYWdlVHlwZXMgPSBbXTtcbiAgICB0aGlzLl9leGl0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIF9nZXRBcmdzKCk6IHN0cmluZ1tdIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmFyZ3MgJiYgdGhpcy5vcHRpb25zLmFyZ3MucmVwbGFjZSkge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5hcmdzLmFyZ3M7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHRoZSBhcmcgY2hhbmdlIG9uIHYxOFxuICAgIGNvbnN0IGJlbG93RWlnaHRlZW4gPSB0aGlzLndvcmtzcGFjZS5sb2NhbEplc3RNYWpvclZlcnNpb24gPCAxODtcbiAgICBjb25zdCBvdXRwdXRBcmcgPSBiZWxvd0VpZ2h0ZWVuID8gJy0tanNvbk91dHB1dEZpbGUnIDogJy0tb3V0cHV0RmlsZSc7XG4gICAgbGV0IGFyZ3MgPSBbJy0tdGVzdExvY2F0aW9uSW5SZXN1bHRzJywgJy0tanNvbicsICctLXVzZVN0ZGVycicsIG91dHB1dEFyZywgdGhpcy5vdXRwdXRQYXRoXTtcbiAgICBpZiAodGhpcy53YXRjaE1vZGUpIHtcbiAgICAgIGFyZ3MucHVzaCh0aGlzLndhdGNoQWxsID8gJy0td2F0Y2hBbGwnIDogJy0td2F0Y2gnKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy50ZXN0TmFtZVBhdHRlcm4pIHtcbiAgICAgIGFyZ3MucHVzaCgnLS10ZXN0TmFtZVBhdHRlcm4nLCB0aGlzLm9wdGlvbnMudGVzdE5hbWVQYXR0ZXJuKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy50ZXN0RmlsZU5hbWVQYXR0ZXJuKSB7XG4gICAgICBhcmdzLnB1c2godGhpcy5vcHRpb25zLnRlc3RGaWxlTmFtZVBhdHRlcm4pO1xuICAgIH1cbiAgICBpZiAodGhpcy53b3Jrc3BhY2UuY29sbGVjdENvdmVyYWdlID09PSB0cnVlKSB7XG4gICAgICBhcmdzLnB1c2goJy0tY292ZXJhZ2UnKTtcbiAgICB9XG4gICAgaWYgKHRoaXMud29ya3NwYWNlLmNvbGxlY3RDb3ZlcmFnZSA9PT0gZmFsc2UpIHtcbiAgICAgIGFyZ3MucHVzaCgnLS1uby1jb3ZlcmFnZScpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLm5vQ29sb3IgPT09IHRydWUpIHtcbiAgICAgIGFyZ3MucHVzaCgnLS1uby1jb2xvcicpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnJlcG9ydGVycykge1xuICAgICAgdGhpcy5vcHRpb25zLnJlcG9ydGVycy5mb3JFYWNoKChyZXBvcnRlcikgPT4ge1xuICAgICAgICBhcmdzLnB1c2goJy0tcmVwb3J0ZXJzJywgcmVwb3J0ZXIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuYXJncykge1xuICAgICAgYXJncy5wdXNoKC4uLnRoaXMub3B0aW9ucy5hcmdzLmFyZ3MpO1xuICAgIH1cbiAgICBpZiAodGhpcy53b3Jrc3BhY2UudXNlRGFzaGVkQXJncykge1xuICAgICAgYXJncyA9IGFyZ3MubWFwKChhcmcpID0+XG4gICAgICAgIGFyZyAmJiBhcmcuc3RhcnRzV2l0aCgnLS0nKSAmJiBhcmcubGVuZ3RoID4gMiA/IGFyZy5yZXBsYWNlKC8oXFxCKShbQS1aXSkvZ20sICctJDInKS50b0xvd2VyQ2FzZSgpIDogYXJnXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBhcmdzO1xuICB9XG5cbiAgc3RhcnQod2F0Y2hNb2RlOiBib29sZWFuID0gdHJ1ZSwgd2F0Y2hBbGw6IGJvb2xlYW4gPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLmRlYnVncHJvY2Vzcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMud2F0Y2hNb2RlID0gd2F0Y2hNb2RlO1xuICAgIHRoaXMud2F0Y2hBbGwgPSB3YXRjaEFsbDtcblxuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9nZXRBcmdzKCk7XG4gICAgY29uc3QgZGVidWdwcm9jZXNzID0gdGhpcy5fY3JlYXRlUHJvY2Vzcyh0aGlzLndvcmtzcGFjZSwgYXJncyk7XG4gICAgdGhpcy5kZWJ1Z3Byb2Nlc3MgPSBkZWJ1Z3Byb2Nlc3M7XG4gICAgZGVidWdwcm9jZXNzLnN0ZG91dC5vbignZGF0YScsIChkYXRhOiBCdWZmZXIpID0+IHtcbiAgICAgIHRoaXMuX3BhcnNlT3V0cHV0KGRhdGEsIGZhbHNlKTtcbiAgICB9KTtcblxuICAgIGRlYnVncHJvY2Vzcy5zdGRlcnIub24oJ2RhdGEnLCAoZGF0YTogQnVmZmVyKSA9PiB7XG4gICAgICAvLyBqZXN0IDIzIGNvdWxkIHNlbmQgdGVzdCByZXN1bHRzIG1lc3NhZ2UgdG8gc3RkZXJyXG4gICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2plc3QvcHVsbC80ODU4XG4gICAgICB0aGlzLl9wYXJzZU91dHB1dChkYXRhLCB0cnVlKTtcbiAgICB9KTtcbiAgICBkZWJ1Z3Byb2Nlc3Mub24oJ2V4aXQnLCAoY29kZTogbnVtYmVyIHwgbnVsbCwgc2lnbmFsOiBzdHJpbmcgfCBudWxsKSA9PiB7XG4gICAgICB0aGlzLl9leGl0ZWQgPSB0cnVlO1xuXG4gICAgICAvLyB0aGlzIGlzIG1haW5seSBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgc2hvdWxkIGJlIGRlcHJlY2F0ZWQgc29vblxuICAgICAgdGhpcy5lbWl0KCdkZWJ1Z2dlclByb2Nlc3NFeGl0Jyk7XG5cbiAgICAgIHRoaXMuZW1pdCgncHJvY2Vzc0V4aXQnLCBjb2RlLCBzaWduYWwpO1xuICAgICAgdGhpcy5wcmV2TWVzc2FnZVR5cGVzLmxlbmd0aCA9IDA7XG4gICAgfSk7XG5cbiAgICBkZWJ1Z3Byb2Nlc3Mub24oJ2Vycm9yJywgKGVycm9yOiBFcnJvcikgPT4ge1xuICAgICAgdGhpcy5lbWl0KCd0ZXJtaW5hbEVycm9yJywgYFByb2Nlc3MgZmFpbGVkOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICB0aGlzLnByZXZNZXNzYWdlVHlwZXMubGVuZ3RoID0gMDtcbiAgICB9KTtcblxuICAgIGRlYnVncHJvY2Vzcy5vbignY2xvc2UnLCAoY29kZTogbnVtYmVyIHwgbnVsbCwgc2lnbmFsOiBzdHJpbmcgfCBudWxsKSA9PiB7XG4gICAgICAvLyB0aGlzIGlzIG1haW5seSBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgc2hvdWxkIGJlIGRlcHJlY2F0ZWQgc29vblxuICAgICAgdGhpcy5lbWl0KCdkZWJ1Z2dlclByb2Nlc3NFeGl0Jyk7XG5cbiAgICAgIHRoaXMuZW1pdCgncHJvY2Vzc0Nsb3NlJywgY29kZSwgc2lnbmFsKTtcbiAgICAgIHRoaXMucHJldk1lc3NhZ2VUeXBlcy5sZW5ndGggPSAwO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIHBhcnNlIHRoZSBzdGRpbi9vdXQgc3RyZWFtIGJ1ZmZlciBmb3IgcmVjb2duaXplZCBtZXNzYWdlcy5cbiAgICpcbiAgICogbm90ZTogaWYgdGhlc2UgbWVzc2FnZXMgY29taW5nIGluIGluIHNlcGFyYXRlIGNodWNrcywgd2UgbWlnaHQgbm90IGJlIGFibGUgdG9cbiAgICogcmVzb2x2ZSBpdCBwcm9wZXJseS4gV2hpbGUgdGhlcmUgaGF2ZW4ndCBiZWVuIG11Y2ggZXZpZGVuY2Ugb2Ygc3VjaCBzY2VuYXJpbyxcbiAgICogaXQncyB3b3J0aCB0byBub3RlIHRoYXQgaXQgY291bGQgYW5kIHdlIG1pZ2h0IG5lZWQgdG8gYnVmZmVyIHRoZW0gaW4gdGhhdCBjYXNlLlxuICAgKiBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2plc3QtY29tbXVuaXR5L2plc3QtZWRpdG9yLXN1cHBvcnQvcHVsbC85I3B1bGxyZXF1ZXN0cmV2aWV3LTIzMTg4ODc1MlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzU3RkRXJyXG4gICAqIEByZXR1cm5zIHtNZXNzYWdlVHlwZX1cbiAgICogQG1lbWJlcm9mIFJ1bm5lclxuICAgKi9cbiAgX3BhcnNlT3V0cHV0KGRhdGE6IEJ1ZmZlciwgaXNTdGRFcnI6IGJvb2xlYW4pOiBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3QgbXNnVHlwZSA9IHRoaXMuZmluZE1lc3NhZ2VUeXBlKGRhdGEpO1xuICAgIHN3aXRjaCAobXNnVHlwZSkge1xuICAgICAgY2FzZSBtZXNzYWdlVHlwZXMudGVzdFJlc3VsdHM6XG4gICAgICAgIHRoaXMuZW1pdCgnZXhlY3V0YWJsZVN0ZEVycicsIGRhdGEsIHtcbiAgICAgICAgICB0eXBlOiBtc2dUeXBlLFxuICAgICAgICB9KTtcbiAgICAgICAgcmVhZEZpbGUodGhpcy5vdXRwdXRQYXRoLCAndXRmOCcsIChlcnIsIF9kYXRhKSA9PiB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBKU09OIHJlcG9ydCBub3QgZm91bmQgYXQgJHt0aGlzLm91dHB1dFBhdGh9YDtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgndGVybWluYWxFcnJvcicsIG1lc3NhZ2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBub1Rlc3RzRm91bmQgPSB0aGlzLmRvUmVzdWx0c0ZvbGxvd05vVGVzdHNGb3VuZE1lc3NhZ2UoKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZXhlY3V0YWJsZUpTT04nLCBKU09OLnBhcnNlKF9kYXRhKSwge1xuICAgICAgICAgICAgICBub1Rlc3RzRm91bmQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnByZXZNZXNzYWdlVHlwZXMubGVuZ3RoID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG1lc3NhZ2VUeXBlcy53YXRjaFVzYWdlOlxuICAgICAgY2FzZSBtZXNzYWdlVHlwZXMubm9UZXN0czpcbiAgICAgICAgdGhpcy5wcmV2TWVzc2FnZVR5cGVzLnB1c2gobXNnVHlwZSk7XG4gICAgICAgIHRoaXMuZW1pdCgnZXhlY3V0YWJsZVN0ZEVycicsIGRhdGEsIHtcbiAgICAgICAgICB0eXBlOiBtc2dUeXBlLFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBubyBzcGVjaWFsIGFjdGlvbiBuZWVkZWQsIGp1c3QgcmVwb3J0IHRoZSBvdXRwdXQgYnkgaXRzIHNvdXJjZVxuICAgICAgICBpZiAoaXNTdGRFcnIpIHtcbiAgICAgICAgICB0aGlzLmVtaXQoJ2V4ZWN1dGFibGVTdGRFcnInLCBkYXRhLCB7XG4gICAgICAgICAgICB0eXBlOiBtc2dUeXBlLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHJlbW92ZSBjbGVhciBzY3JlZW4gZXNjYXBlIHNlcXVlbmNlXG4gICAgICAgICAgdGhpcy5lbWl0KCdleGVjdXRhYmxlT3V0cHV0JywgZGF0YS50b1N0cmluZygpLnJlcGxhY2UoJ1x1MDAxYlsySlx1MDAxYltIJywgJycpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZXZNZXNzYWdlVHlwZXMubGVuZ3RoID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1zZ1R5cGU7XG4gIH1cblxuICBydW5KZXN0V2l0aFVwZGF0ZUZvclNuYXBzaG90cyhjb21wbGV0aW9uOiAoKSA9PiB2b2lkLCBhcmdzPzogc3RyaW5nW10pIHtcbiAgICBjb25zdCBkZWZhdWx0QXJncyA9IFsnLS11cGRhdGVTbmFwc2hvdCddO1xuXG4gICAgY29uc3QgdXBkYXRlUHJvY2VzcyA9IHRoaXMuX2NyZWF0ZVByb2Nlc3ModGhpcy53b3Jrc3BhY2UsIFsuLi5kZWZhdWx0QXJncywgLi4uKGFyZ3MgfHwgW10pXSk7XG4gICAgdXBkYXRlUHJvY2Vzcy5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICBjb21wbGV0aW9uKCk7XG4gICAgfSk7XG4gIH1cblxuICBjbG9zZVByb2Nlc3MoKSB7XG4gICAgaWYgKCF0aGlzLmRlYnVncHJvY2VzcyB8fCB0aGlzLl9leGl0ZWQpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLmxvZyhgcHJvY2VzcyBoYXMgbm90IHN0YXJ0ZWQgb3IgYWxyZWFkeSBleGl0ZWRgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpIHtcbiAgICAgIC8vIFdpbmRvd3MgZG9lc24ndCBleGl0IHRoZSBwcm9jZXNzIHdoZW4gaXQgc2hvdWxkLlxuICAgICAgc3Bhd24oJ3Rhc2traWxsJywgWycvcGlkJywgYCR7dGhpcy5kZWJ1Z3Byb2Nlc3MucGlkfWAsICcvVCcsICcvRiddKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8ga2lsbCBhbGwgcHJvY2VzcyB3aXRoIHRoZSBzYW1lIFBHSUQsIGkuZS5cbiAgICAgICAgLy8gYXMgYSBkZXRhY2hlZCBwcm9jZXNzLCBpdCBpcyB0aGUgc2FtZSBhcyB0aGUgUElEIG9mIHRoZSBsZWFkZXIgcHJvY2Vzcy5cbiAgICAgICAgcHJvY2Vzcy5raWxsKC10aGlzLmRlYnVncHJvY2Vzcy5waWQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBpZiBhbnl0aGluZyBnb2VzIHdyb25nLCBmYWxsYmFjayB0byB0aGUgb2xkIGJlbmF2aW9yXG4gICAgICAgIC8vIGtub3dpbmcgdGhpcyBjb3VsZCBsZWF2ZSBvcnBoYW4gcHJvY2Vzcy4uLlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgYGZhaWxlZCB0byBraWxsIHByb2Nlc3MgZ3JvdXAsIHRoaXMgY291bGQgbGVhdmUgc29tZSBvcnBoYW4gcHJvY2VzcyB3aG9zZSBwcGlkPSR7XG4gICAgICAgICAgICB0aGlzLmRlYnVncHJvY2Vzcz8ucGlkIHx8ICdwcm9jZXNzLW5vbi1leGlzdCdcbiAgICAgICAgICB9LiBlcnJvcj1gLFxuICAgICAgICAgIGVcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5kZWJ1Z3Byb2Nlc3M/LmtpbGwoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5kZWJ1Z3Byb2Nlc3MgPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xuICBmaW5kTWVzc2FnZVR5cGUoYnVmOiBCdWZmZXIpOiBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3Qgbm9UZXN0UmVnZXggPSAvTm8gdGVzdHMgZm91bmQgcmVsYXRlZCB0byBmaWxlcyBjaGFuZ2VkIHNpbmNlICgobGFzdCBjb21taXQpfChcIlthLXowLTldK1wiKSkuLztcbiAgICBjb25zdCB3YXRjaFVzYWdlUmVnZXggPSAvXlxccypXYXRjaCBVc2FnZVxcYi87XG4gICAgY29uc3QgdGVzdFJlc3VsdHNSZWdleCA9IC9UZXN0IHJlc3VsdHMgd3JpdHRlbiB0by87XG5cbiAgICBjb25zdCBjaGVja3MgPSBbXG4gICAgICB7cmVnZXg6IHRlc3RSZXN1bHRzUmVnZXgsIG1lc3NhZ2VUeXBlOiBtZXNzYWdlVHlwZXMudGVzdFJlc3VsdHN9LFxuICAgICAge3JlZ2V4OiBub1Rlc3RSZWdleCwgbWVzc2FnZVR5cGU6IG1lc3NhZ2VUeXBlcy5ub1Rlc3RzfSxcbiAgICAgIHtyZWdleDogd2F0Y2hVc2FnZVJlZ2V4LCBtZXNzYWdlVHlwZTogbWVzc2FnZVR5cGVzLndhdGNoVXNhZ2V9LFxuICAgIF07XG5cbiAgICBjb25zdCBzdHIgPSBidWYudG9TdHJpbmcoJ3V0ZjgnKTtcbiAgICBjb25zdCBtYXRjaCA9IGNoZWNrcy5maW5kKCh7cmVnZXh9KSA9PiByZWdleC50ZXN0KHN0cikpO1xuICAgIHJldHVybiBtYXRjaCA/IG1hdGNoLm1lc3NhZ2VUeXBlIDogbWVzc2FnZVR5cGVzLnVua25vd247XG4gIH1cblxuICBkb1Jlc3VsdHNGb2xsb3dOb1Rlc3RzRm91bmRNZXNzYWdlKCk6IGJvb2xlYW4ge1xuICAgIGlmICh0aGlzLnByZXZNZXNzYWdlVHlwZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmV2TWVzc2FnZVR5cGVzWzBdID09PSBtZXNzYWdlVHlwZXMubm9UZXN0cztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wcmV2TWVzc2FnZVR5cGVzLmxlbmd0aCA9PT0gMikge1xuICAgICAgcmV0dXJuIHRoaXMucHJldk1lc3NhZ2VUeXBlc1swXSA9PT0gbWVzc2FnZVR5cGVzLm5vVGVzdHMgJiYgdGhpcy5wcmV2TWVzc2FnZVR5cGVzWzFdID09PSBtZXNzYWdlVHlwZXMud2F0Y2hVc2FnZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUF3QztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFeEM7QUFDQTtBQUNBO0FBQUEsSUFDcUJBLE1BQU07RUFBQTtFQUFBO0VBS3pCOztFQUdBOztFQWFBO0VBQ0EsZ0JBQVlDLFNBQTJCLEVBQUVDLE9BQWlCLEVBQUU7SUFBQTtJQUFBO0lBQzFEO0lBRUEsTUFBS0MsY0FBYyxHQUFJRCxPQUFPLElBQUlBLE9BQU8sQ0FBQ0UsYUFBYSxJQUFLQSxzQkFBYTtJQUN6RSxNQUFLRixPQUFPLEdBQUdBLE9BQU8sSUFBSSxDQUFDLENBQUM7SUFDNUIsTUFBS0QsU0FBUyxHQUFHQSxTQUFTO0lBQzFCLE1BQUtJLFVBQVUsR0FBR0MsSUFBSSxDQUFDQyxJQUFJLENBQUMsSUFBQUMsVUFBTSxHQUFFLHdCQUFpQixNQUFLUCxTQUFTLENBQUNRLGdCQUFnQixJQUFJLEVBQUUsV0FBUTtJQUNsRyxNQUFLQyxnQkFBZ0IsR0FBRyxFQUFFO0lBQzFCLE1BQUtDLE9BQU8sR0FBRyxLQUFLO0lBQUM7RUFDdkI7RUFBQztJQUFBO0lBQUEsT0FFRCxvQkFBcUI7TUFDbkIsSUFBSSxJQUFJLENBQUNULE9BQU8sQ0FBQ1UsSUFBSSxJQUFJLElBQUksQ0FBQ1YsT0FB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